

# 引用与指针的区别与联系
> 引用是一个变量的别名，是一个对象的代替名，用符号&来引导，对一个变量的引用做任何操作就是对这个变量做相同的操作。
区别：
>* 指针是一个变量的地址，而引用则是变量的别名。因此，在程序中表示对象变量时，前者要通过取内容运算符「*」，而后者可以直接代表。像普通变量那样。
>* 指针是可变的，可以忽而指向变量 a，忽而指向变量 b。而引用则只能在声明时一次初始化，不能在随后变成别的变量的引用
>* 引用没有空间的概念他不占用内存，仅在编译时有效。

>构造函数中变量的初始化顺序是按其定义的顺序，与初始化列表中的顺序无关

# 堆和栈的区别
> 1. 数据结构的堆和栈
>* 栈是一种可以实现“先进后出”（或者称为“后进先出”）的存储结构
>* 堆则是一种经过排序的树形数据结构，常用来实现优先队列等，是一种特殊的完全二叉树。
分为最大堆和最小堆，最大堆的根节点最大，最小堆的根节点最小
每一个子节点都小于等于或者大于等于其父节点的值。队列是一种可以实现“先进先出”的存储结构
> 2. 内存分配中的堆和栈
>* 代码区
>>* 程序被操作系统加载到内存时，所有可执行的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运行时，这段区域数据不可被修改只可以被执行。
>* 全局区/静态区
>>* 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在一块区域）。代码执行期间一直占用内存！
>* 堆/自由存储区
>>* 堆是不连续的内存区域，获得的空间比较灵活，也比较大，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。需要程序员申请的内存空间，空间的释放一般由程序员控制(比如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运行完毕时操作系统会对该内存空间进行回收。
>* 栈
>>* 栈是一块连续的内存的区域，一般栈的大小都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提示overflow。存放的通常是变量通常是局部变量、函数参数等。
>* 文字常量区
>>* 常量字符串就是放在这里的。 程序结束后由系统释放。
>* bss段
>>* 定义而没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和大小，相当于一个占位符。
>* 一个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss 里面装载了未被初始化的数据；如图：

# new和delete是如何实现的，new 与 malloc的异同处
>* new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象初始化；delete接受一个动态对象的指针，销毁对象，并释放对应内存。
>* operator new 申请内存之后不对内存进行初始化，直接返回申请内存的指针。
>* new申请一片内存，然后调用构造函数，返回一个申请内存的指针。内置数据类型没有构造函数

# c和c++的区别
>* c是面向过程编程
>* c++是面向对象编程
>* 管理动态内存的方法不一样，c是malloc/free函数，c++是new/delete关键字，c++支持函数重载
>* c++有引用

> 设计思想上：
>* C++是面向对象的语言，而C是面向过程的结构化编程语言
> 语法上：
>* C++具有封装、继承和多态三种特性
>* C++相比C，增加多许多类型安全的功能，比如强制类型转换、
>* C++支持范式编程，比如模板类、函数模板等

# struct和class的区别

>* C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

> C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
>* 使用 class 时，类中的成员如果不声明，默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
>* class 继承默认是 private 继承，而 struct 继承默认是 public 继承
>* class 可以使用模板，而 struct 不能
>* struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。

# define 和const的区别（编译阶段、安全性、内存占用等）

>* 用#define MAX 255定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

>* 用const float MAX = 255; 定义的常量有类型名字，存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而#define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多；

>* 用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；

>* 用define可以定义一些简单的函数，const是不可以定义函数的.
>>* 编译器处理方式
>>> 1. define – 在预处理阶段进行替换
>>> 2. const – 在编译时确定其值
>>* 类型检查
>>> 1. define – 无类型，不进行类型安全检查，可能会产生意想不到的错误
>>> 2. const – 有数据类型，编译时会进行类型检查
>>* 内存空间
>>> 1. define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大
>>> 2. const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝
>>* 其他
>>> 在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。



# 在C++中const和static的用法（定义，用途）
>* const
>> 用法：修饰变量，参数，返回值。 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性。const 允许指定语义约束，告诉编译器哪些变量是不可以改变的。
修饰变量：C语言中const将一个变量转化为常变量，存储在静态文本段，只有读取权限，C++中同样会将一个变量转化成常量，C++会对其进行优化，将其放入寄存器中，如果想去内存中读取该数据时，我们可以使用volatile关键字进行修饰，保证其可见性。
>* 修饰指针变量： 如果const位于* 左侧时，不能修改指针所指的对象
如果const位于* 右侧时，不能修改指针的指向，所以必须初始化。
>* 修饰参数：作用是原参数在该函数中不可被改变。
>* 修饰的返回值：也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。

>* static
>* 全局变量：修饰的全局变量，指定其内部链接，也就是只能本文件使用。
>* 局部变量：修饰的局部变量，改变其生命周期，并不会修改器作用域。
>* 普通函数：修饰的普通函数，指定其内部链接，也就是只能本文可见。

# const和static在类中使用的注意事项（定义、初始化和使用）

>* const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。
>* static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。
>* 在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static
>* 在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
>* const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
>* c++11中实现了类内初始化，所以可以在类内实现const数据成员的初始化，作用域是整个类，也就是说该类的每一个对象的该数据成员都一样
>* const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。

```
#include <iostream>  
using namespace std;  
class A  
{  
public:  
      A(int a);  
      static void print();//静态成员函数  
private:  
      static int aa;//静态数据成员的声明  
       static const int count;//常量静态数据成员（可以在构造函数中初始化）  
       const int bb;//常量数据成员  
};  
int A::aa=0;//静态成员的定义+初始化  
const int A::count=25;//静态常量成员定义+初始化  
A::A(int a):bb(a)//常量成员的初始化  
{  
      aa+=1;  
}  
void A::print()  
{  
      cout<<"count="<<count<<endl;  
      cout<<"aa="<<aa<<endl;  
}  
 
void main()  
{  
      A a(10);  
      A::print();//通过类访问静态成员函数  
      a.print();//通过对象访问静态成员函数  
}  

```

>* 类的常量初始化列表
>> 常量数据成员的初始化，只能在构造函数初始化列表中初始化。初始化的格式——类名::构造函数:常量数据成员

# C++中的const类成员函数（用法和意义），以及和非const成员函数的区别
>* const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。
>* 常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字
>* 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。
>* 函数头部的结尾加上 const 
>* 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量
的值，例如char * getname() const。

# C++的顶层const和底层const
>* 顶层const：const修饰指针本身
>* 底层const：const修饰指针指向的那个内存数据

```
 int a = 1;
 const int*p1 = &a; //p1是底层const，通过p1不能改变p1指向的数据a。p1本身可变。
 int const*p2 = &a; //同上，p2是底层const，通过p2不能改变p2指向的数据a。p2本身可变。
 int* const p3 = &a; //p3是顶层const，p3本身不能改变，始终指向a，但是通过p3可以改变a的值
 const int* const p4 = &a; //顶层const和底层const的结合。p4本身是const，且通过p4无法改变它指向的数据a
```

# final和override关键字
> final限定某个类不能被继承，或者限定某个虚函数不能被重写，同时该关键字要写到类或者虚函数的后面。

```
struct A
{
    virtual void fun() final; //该虚函数不能被重写
    virtual bar() final; //err: 非虚函数不能被final修饰
};

struct B final : A
{
    void fun(); //err: 该虚函数不能被重写，因为在A中已经被声明为final
};

struct C : B //err: B是final
{
};
```

> override关键字保证了派生类中声明重写的函数与基类虚函数有相同的签名，可避免一些拼写错误，如加了此关键字但基类中并不存在相同的函数就会报错，也可以防止把本来想重写的虚函数声明成了重载。同时在阅读代码时如果看到函数声明后加了此关键字就能立马知道此函数是重写了基类虚函数。保证重写虚函数的正确性的同时也提高了代码可读性。

# 拷贝初始化和直接初始化，初始化和赋值的区别

>* 对象不存在，且没用别的对象来初始化，调用构造函数
>* 对象不存在，且用别的对象来初始化，调用拷贝构造
>* 对象存在，用别的对象给他赋值，就是赋值函数
https://www.cnblogs.com/cposture/p/4925736.html
https://blog.csdn.net/ljianhui/article/details/9245661
https://blog.csdn.net/splendid7/article/details/81537706
https://www.cnblogs.com/qingergege/p/7607089.html（移动构造函数）

>（1）什么是拷贝初始化（也称为复制初始化）：将一个已有的对象拷贝到正在创建的对象，如果需要的话还需要进行类型转换。拷贝初始化发生在下列情况：
1.使用赋值运算符定义变量
2.将对象作为实参传递给一个非引用类型的形参
3.将一个返回类型为非引用类型的函数返回一个对象
4.用花括号列表初始化一个数组中的元素或一个聚合类中的成员

>（2）什么是直接初始化：在对象初始化时，通过括号给对象提供一定的参数，并且要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数

```
ClassTest ct2 = "ab";//复制初始化
ClassTest ct2("ab");//直接初始化
```

>* 直接初始化和拷贝初始化效率基本一样，因为在底层的实现基本一样，所以将拷贝初始化改为直接初始化效率提高不大

>* 拷贝初始化什么时候使用拷贝构造函数：？？？

> 赋值表达式右边是一个对象
直接初始化时，括号内的参数是一个对象
用花括号列表初始化一个数组中的元素或一个聚合类中的成员
将一个返回类型为引用类型的函数返回一个对象
形参为非引用类型的函数，其中是将实参拷贝到临时对象

>* 什么时候使用到拷贝赋值运算符：？？？

> 赋值表达式右边是一个左值对象（如果需要，可以调用构造函数类型转换，生成一个临时对象）
当赋值表达式右边是一个右值对象，且没有定义移动赋值运算符函数
什么时候使用移动赋值运算符：？？？
当赋值表达式右边是一个右值对象，且定义了移动赋值运算符函数

# extern "C"的用法
> 为了能够正确的在C++ 代码中调用C语言的代码；在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；

# 模板函数和模板类的特例化
> 函数模板实例化有两个方面，一个是隐式实例化，一个是显式实例化。

>* 下面为显式实例化:

```
#include<iostream>
#include<vector>
using namespace std;
template <typename T>      //模板函数
void output(T a)
{
	cout << a << endl;
}

template <typename A>
class B                    //模板类
{
public:
	void swp(A a);
};
template<typename A>
void B<A>::swp(A a)
{
	cout << a << endl;
}
int main()
{
	cout << "下面是函数模板实例化" << endl;
	output<int>(1);           //函数模板实例化
	output<float>(1.2);
	output<char>('a');

	cout << "下面是类模板实例化" << endl;
	B<int> b1;
	b1.swp(1);
	B<float> b2;
	b2.swp(1.2);
	B<char> b3;
	b3.swp('a');
	system("pause");
}
```

> 注意：类模板的成员函数都是函数模板

# C++的STL源码

> 侯捷老师的STL源码剖析书籍与视频，其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）


# STL源码中的hashtable的实现

> `hash_table`是STL中`hash_map` 和 `hash_set` 的内部数据结构，`hash_table`的插入/删除/查找的时间复杂度都为O(1),是查找速度最快的一种数据结构，但是`hash_table`中的数据是无序的，一般也只有在数据不需要排序，只需要满足快速查找/插入/删除的时候使用`hash_table`。`hash_table`的扩展是将原`hash_table`中的数据摘下来插入到一个临时的`hash_table`中，因为每个桶都使用list来实现的，因此插入删除都不存在内存copy，所以也是很高效的，最后再将临时`hash_table`和原来的`hash_table`（此时已经为空）交换。

# STL中unordered_map和map的区别和应用场景
>* 头文件

```
map: #include < map >
unordered_map: #include < unordered_map >
```
> 内部实现机理
>* map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
>* unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的

> 优缺点以及适用处
>* map优点：
有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
红黑树，内部实现一个红黑数使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高
>* map缺点：
空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
适用处，对于那些有顺序要求的问题，用map会更高效一些

>* unordered_map优点：
因为内部实现了哈希表，因此其查找速度非常的快
>* unordered_map缺点：
哈希表的建立比较耗费时间
适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map


# STL中vector的实现
> 新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。

``` 
#include <cstddef>
#include <stdexcept>
#include <memory>
#include <iterator>

template <typename T>
class vector
{
  public:
    using value_type = T;
    using iterator = value_type *;
    using size_type = std::size_t;

  public:
    vector() = default;
    ~vector();
    iterator begin() const;
    iterator end() const;
    size_type size() const;
    value_type &operator[](size_type i) const;
    value_type &at(size_type i) const;
    void push_back(const value_type &new_elem);
    void pop_back();

  private:
    iterator startptr = nullptr;
    iterator endptr = nullptr;
    iterator capptr = nullptr;
    std::allocator<value_type> alloc;

  private:
    void check_cap();
    void free();
}
```

> 删除元素：删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。
删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。

# STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）
>* 顺序容器：vector,deque是随机访问迭代器；list是双向迭代器
>* 容器适配器：stack,queue,priority_queue没有迭代器
>* 关联容器：set,map,multiset,multimap是双向迭代器
unordered_set,unordered_map,unordered_multiset,unordered_multimap是前向迭代器

# STL中的traits技法
>* type_traits  负责萃取型别的特性

>* iterator_traits 负责萃取迭代器的特性

>* char traits

>* allocator_traits

>* pointer_traits

>* array_traits


# vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。
> 在一个vector的尾部之外的任何位置添加元素，都需要重新移动元素。
而且，向一个vector添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间（因为vector在内存中的地址是连续的，所以加入一个可能造成地址不够）

> 解决方案

> 预先通过reverse()分配内存
