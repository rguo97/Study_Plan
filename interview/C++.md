

# 引用与指针的区别与联系
> 引用是一个变量的别名，是一个对象的代替名，用符号&来引导，对一个变量的引用做任何操作就是对这个变量做相同的操作。
区别：
>* 指针是一个变量的地址，而引用则是变量的别名。因此，在程序中表示对象变量时，前者要通过取内容运算符「*」，而后者可以直接代表。像普通变量那样。
>* 指针是可变的，可以忽而指向变量 a，忽而指向变量 b。而引用则只能在声明时一次初始化，不能在随后变成别的变量的引用
>* 引用没有空间的概念他不占用内存，仅在编译时有效。

>构造函数中变量的初始化顺序是按其定义的顺序，与初始化列表中的顺序无关

# 堆和栈的区别
> 1. 数据结构的堆和栈
>* 栈是一种可以实现“先进后出”（或者称为“后进先出”）的存储结构
>* 堆则是一种经过排序的树形数据结构，常用来实现优先队列等，是一种特殊的完全二叉树。
分为最大堆和最小堆，最大堆的根节点最大，最小堆的根节点最小
每一个子节点都小于等于或者大于等于其父节点的值。队列是一种可以实现“先进先出”的存储结构
> 2. 内存分配中的堆和栈
>* 代码区
>>* 程序被操作系统加载到内存时，所有可执行的代码被加载到代码区，也叫代码段，存储程序的代码指令。程序运行时，这段区域数据不可被修改只可以被执行。
>* 全局区/静态区
>>* 程序中的静态变量、全局变量存放在此区域（初始化的全局变量和静态变量在一块区域）。代码执行期间一直占用内存！
>* 堆/自由存储区
>>* 堆是不连续的内存区域，获得的空间比较灵活，也比较大，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。需要程序员申请的内存空间，空间的释放一般由程序员控制(比如new, delete, malloc, free)。当程序员没有释放该内存空间的时候，程序运行完毕时操作系统会对该内存空间进行回收。
>* 栈
>>* 栈是一块连续的内存的区域，一般栈的大小都是预先设置好的，如果申请的空间超过栈的剩余空间时，将提示overflow。存放的通常是变量通常是局部变量、函数参数等。
>* 文字常量区
>>* 常量字符串就是放在这里的。 程序结束后由系统释放。
>* bss段
>>* 定义而没有赋初值的全局变量和静态变量,放在这个区域，通常只是记录变量名和大小，相当于一个占位符。
>* 一个程序本质上都是由.bss段、.data段、.text段三个组成的。.data段包含三个部分：heap(堆)、stack(栈)和静态数据区。.text段存放代码区。.bss 里面装载了未被初始化的数据；如图：

# new和delete是如何实现的，new 与 malloc的异同处
>* new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象初始化；delete接受一个动态对象的指针，销毁对象，并释放对应内存。
>* operator new 申请内存之后不对内存进行初始化，直接返回申请内存的指针。
>* new申请一片内存，然后调用构造函数，返回一个申请内存的指针。内置数据类型没有构造函数

# c和c++的区别
>* c是面向过程编程
>* c++是面向对象编程
>* 管理动态内存的方法不一样，c是malloc/free函数，c++是new/delete关键字，c++支持函数重载
>* c++有引用

> 设计思想上：
>* C++是面向对象的语言，而C是面向过程的结构化编程语言
> 语法上：
>* C++具有封装、继承和多态三种特性
>* C++相比C，增加多许多类型安全的功能，比如强制类型转换、
>* C++支持范式编程，比如模板类、函数模板等

# struct和class的区别

>* C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

> C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
>* 使用 class 时，类中的成员如果不声明，默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
>* class 继承默认是 private 继承，而 struct 继承默认是 public 继承
>* class 可以使用模板，而 struct 不能
>* struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。

# define 和const的区别（编译阶段、安全性、内存占用等）

>* 用#define MAX 255定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；

>* 用const float MAX = 255; 定义的常量有类型名字，存放在内存的静态区域中，在程序运行过程中const变量只有一个拷贝，而#define 所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多；

>* 用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；

>* 用define可以定义一些简单的函数，const是不可以定义函数的.
>>* 编译器处理方式
>>> 1. define – 在预处理阶段进行替换
>>> 2. const – 在编译时确定其值
>>* 类型检查
>>> 1. define – 无类型，不进行类型安全检查，可能会产生意想不到的错误
>>> 2. const – 有数据类型，编译时会进行类型检查
>>* 内存空间
>>> 1. define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大
>>> 2. const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝
>>* 其他
>>> 在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。



# 在C++中const和static的用法（定义，用途）
>* const
>> 用法：修饰变量，参数，返回值。 C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性。const 允许指定语义约束，告诉编译器哪些变量是不可以改变的。
修饰变量：C语言中const将一个变量转化为常变量，存储在静态文本段，只有读取权限，C++中同样会将一个变量转化成常量，C++会对其进行优化，将其放入寄存器中，如果想去内存中读取该数据时，我们可以使用volatile关键字进行修饰，保证其可见性。
>* 修饰指针变量： 如果const位于* 左侧时，不能修改指针所指的对象
如果const位于* 右侧时，不能修改指针的指向，所以必须初始化。
>* 修饰参数：作用是原参数在该函数中不可被改变。
>* 修饰的返回值：也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。

>* static
>* 全局变量：修饰的全局变量，指定其内部链接，也就是只能本文件使用。
>* 局部变量：修饰的局部变量，改变其生命周期，并不会修改器作用域。
>* 普通函数：修饰的普通函数，指定其内部链接，也就是只能本文可见。

# const和static在类中使用的注意事项（定义、初始化和使用）

>* const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。
>* static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。
>* 在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static
>* 在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
>* const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
>* c++11中实现了类内初始化，所以可以在类内实现const数据成员的初始化，作用域是整个类，也就是说该类的每一个对象的该数据成员都一样
>* const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。

```
#include <iostream>  
using namespace std;  
class A  
{  
public:  
      A(int a);  
      static void print();//静态成员函数  
private:  
      static int aa;//静态数据成员的声明  
       static const int count;//常量静态数据成员（可以在构造函数中初始化）  
       const int bb;//常量数据成员  
};  
int A::aa=0;//静态成员的定义+初始化  
const int A::count=25;//静态常量成员定义+初始化  
A::A(int a):bb(a)//常量成员的初始化  
{  
      aa+=1;  
}  
void A::print()  
{  
      cout<<"count="<<count<<endl;  
      cout<<"aa="<<aa<<endl;  
}  
 
void main()  
{  
      A a(10);  
      A::print();//通过类访问静态成员函数  
      a.print();//通过对象访问静态成员函数  
}  

```

>* 类的常量初始化列表
>> 常量数据成员的初始化，只能在构造函数初始化列表中初始化。初始化的格式——类名::构造函数:常量数据成员

# C++中的const类成员函数（用法和意义），以及和非const成员函数的区别
>* const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。
>* 常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字
>* 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。
>* 函数头部的结尾加上 const 
>* 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量
的值，例如char * getname() const。

# C++的顶层const和底层const
>* 顶层const：const修饰指针本身
>* 底层const：const修饰指针指向的那个内存数据

```
 int a = 1;
 const int*p1 = &a; //p1是底层const，通过p1不能改变p1指向的数据a。p1本身可变。
 int const*p2 = &a; //同上，p2是底层const，通过p2不能改变p2指向的数据a。p2本身可变。
 int* const p3 = &a; //p3是顶层const，p3本身不能改变，始终指向a，但是通过p3可以改变a的值
 const int* const p4 = &a; //顶层const和底层const的结合。p4本身是const，且通过p4无法改变它指向的数据a
```
